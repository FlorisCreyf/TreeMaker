\documentclass[10pt]{article}
\title{Plant Generator}
\date{\today}
\usepackage[margin=1in]{geometry}
\usepackage{svg}
\usepackage{calc}
\usepackage{float}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\renewcommand{\footrulewidth}{0pt}
\renewcommand{\headrulewidth}{0.5pt}

\makeatletter
\begin{document}
\begin{center}
 \includesvg{resources/icon.svg} \\
 \vspace{1em}
 \begin{huge} \@title \end{huge} \\
 \vspace{1em}
 \@date
\end{center}
\tableofcontents
\pagebreak

\section{Introduction}

The project is split in two parts. The editor handles all user input and provides realtime feedback. It defines widgets, commands, selection types, and data structures for rendering. The plant generator generates plant structures and meshes, and it provides a means to export the result.

\begin{figure}[H]
\centering
\includesvg{resources/diagrams/outline.svg} \\
\caption{A high-level overview of the program.}
\end{figure}

\section{Background}

\subsection{Ray Tracing Model}

A plant is grown over a certain number of growth cycles. A bounding box is generated at the beginning of each cycle and is used to construct a dome (the sky). Rays (light) originating on the dome intersect leaves to determine the efficiency of each stem in the plant. A stem is efficient if many intersections occur with its leaves and is grown by a random growth factor. Otherwise, if a stem receives no or little ray intersections, then the stem is shedded by the plant (known as cladoptosis). Remaining stems will grow in the average directions of rays that intersect with their leaves.

Each stem develops buds at the beginning of each iteration. Leaves form along the dormant nodes in the current iteration, and stems grow from the nodes in the following iteration. As stems grow older, a branch collar (swelling) forms at the base to secure the stem to the parent stem. Additionally, growth of lateral stems is suppressed by some factor depending on the distance to the apex of the parent stem. This suppression factor is intended to approximate the effects of auxin hormones that control the apical dominance of the plant.

\subsection{Internal and External Influences}

Auxin (IAA) lengthens cells by increasing cell wall elasticity. Auxin is transported away from light through the shifting of PIN proteins in cell membranes. This process results in stems bending towards light. A common hypothesis is that auxin determines the apical dominance of the plant through a source-sink model. Fully saturating stems with auxin prevents axillary buds from releasing auxin into the stem and prevents further growth. The effects of auxin are countered with cytokinins (CK) that stimulate growth.

Formation of reaction wood is required for stems to grow upward or otherwise stems will bend down as their mass increases. Angiosperms produce tension wood in the upper part of the stem. Gymnosperms produce compression wood in the lower part of the stem. A stem under apical control develops only enough reaction wood to retain its angle but not enough to grow upward. Reaction wood enables one of the axillary stems to become the new central leader if the apical node is removed.

The apical meristem exhibits determinate growth if it produces a flower. The loss of apical control causes sympodial branching. Monopodial branching occurs when the apical meristem exhibits indeterminate growth. Dichotomous branching occurs when the apical node splits in two.

Growth is limited by the nitrogen concentration of the soil. More energy is put into roots when nitrogen is scarce. More stems are grown when nitrogen is abundant.

\subsection{Terms}

\begin{itemize}
\item Phytomer: a unit containing a node, internode, and axillary bud
\item Phyllotaxis: the arrangement of leaves
\item Acropetal: leaves and flowers start developing at the top
\item Basipetal: leaves and flowers start developing at the bottom
\item Orthotropic: vertical growth
\item Plagiotropic: horizontal growth
\item Anisotropic: unequal growth in different directions
\item Isotropic: equal growth in all directions
\item Excurrent: the plant maintains a single central leader
\item Decurrent: lateral stems compete with the central leader
\item Acrotony: stems first develop near the apex
\item Mesotony: stems first develop in the center
\item Basitony: stems first develop at the base
\item Inflorescence: a cluster of flowers including the stem
\end{itemize}

\pagebreak
\section{Editor}

\subsection{Camera}

The camera produces matrices for transforming the world space into the screen space. It also produces inverse matrices so that the screen space can be transformed back into the world space. This is useful for object selection.
\begin{itemize}
\item \texttt{Vec3 target}: The point the camera is pointed at.
\item \texttt{float distance}: The distance the camera is from the target.
\item \texttt{float x}: A rotation around the x-axis.
\item \texttt{float y}: A rotation around the y-axis.
\end{itemize}

The \texttt{x} and \texttt{y} rotations are used to calculate a point on a sphere. The location of the camera is therefore: (\textit{location on sphere}) (\textit{distance}) + \textit{target}. The \texttt{x} and \texttt{y} rotations are also used to maintain the orientation of the camera even when the view direction and up vectors are parallel.

\subsection{Commands}

The editor uses the command pattern to store all user invocable commands. This allows each command to be easily associated with a key combination, and this makes it possible to implement an undo/redo system without having to copy the entire application state. Commands are required to have execute, undo, and redo methods. The downside of this approach is that the the undo behavior of prior commands will be wrong if a command improperly undoes its changes.

\subsubsection{Move Commands}

The cursor position is converted into a ray pointing into the world space in order to move an object in the world space using the cursor. The ray is used to create a point in the world space by intersecting with a plane that is parallel to the camera direction. Points are moved by the difference of the initial and last (cursor generated) points.

There is also a need to move points along paths instead of straight through the world space. This functions differently from the first method. Instead of converting the cursor position to a point in the world space, the points along the path are converted to the screen space. The cursor position is projected onto the (now two-dimensional) path to determine a new point.

\subsubsection{Save Commands}

The internal properties of stems and leaves can be adjusted using a property editor. The program checks for changes within the selection whenever a property editor loses focus. A save command storing the original objects is inserted into the history if changes were made.

\subsection{Resources}

A \texttt{SharedResources} object stores all the shader programs and materials that are needed across all OpenGL widgets. Default images are automatically loaded from the \texttt{resources} file, and shaders are automatically loaded from the \texttt{shaders} file. Signals are emitted whenever materials are modified so that property editors can adjust their combo boxes to match the global state.

\subsection{History}

The history maintains a list of past and future commands. The timestamps within commands are used to verify that new commands are more recent than the previous command. Commands can be flipped if their timestamps are out of order, which could happen if they are added to the history during focus events.

\pagebreak
\section{Generator}

\subsection{Stems}

The positions of stems are stored as distances along parent stems. Stems internally calculate their location in the world space when distances are changed and when the paths of ancestor stems are changed. Some resources, such as materials and curves, are referenced with indices. The indices point to resources located in the plant object.

\subsubsection{Bark Ridges and Branch Collars}

The branch collar is a swelling at the base of the stem that increases the structural integrity of the joint. The bark ridge can be generated by using two B\'{e}zier curves, but that would require finding a third point and increasing the complexity of the algorithm.

\begin{figure}[H]
\centering
\includesvg{resources/diagrams/collar.svg} \\
\caption{The first cross section is scaled along the parent stem direction (1) and is intersected with the parent's surface (2). A spline connects the transformed cross section with the second cross section (3).}
\end{figure}

\subsubsection{Bifurcation}

The fork is generated by evaluating the problem from two separate views. The solution assumes that all sections have the same even number of points.

\begin{enumerate}
\item Skip overlapping cross sections. Assuming that the paths are lines, the Law of Sines can be used to find a distance wherein no cross sections should be generated. The distance is $ d $, the radius is $ r $, and the angle between the vectors is $ \theta $. Refer to Figure \ref{fig:forkside}.
\[ d = r \cdot \frac{\sin[(\pi-\theta)\div2]}{\sin (\theta\div2)} \]
A more flexible approach is to project points along one path onto the other path and measure the distances. This paths are evaluated in an alternating manner so that the algorithm exits the first time the paths stop intersecting so that not all points need to be evaluated. Alternation occurs whenever a check fails. Refer to Figure \ref{fig:path}.

\begin{figure}[H]
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/fork_side.svg}
  \caption{The length of the top edge of the shaded triangle is the distance that is required to be free of cross sections.} \label{fig:forkside}
 \end{minipage}
 \hfill
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/path.svg}
  \caption{Points along one path are projected on the line segments of the second path. The paths intersect when the distances of the projections are less than the diameter of the cross sections and the projected points fall within the line segments.} \label{fig:path}
 \end{minipage}
\end{figure}

\item Rotate the child cross sections so that they have the same planar orientation as the last parent cross section. Rotate the average fork direction into the global up axis ($ \hat{k} $), and project the child direction on the plane $ \hat{k} $. Refer to Figure \ref{fig:forkdiv} why the average fork direction is used instead of the parent cross section normal. Find the nearest vector that has an angle that is a multiple of $ \theta_{\delta} = 2 \pi \div s $, where $ s $ is the number of points for each cross section. Refer to Figure \ref{fig:forktopangle}.
\[ \vec{b}_{\theta} = \left \lfloor \frac{\arccos(\vec{a}_x)}{\theta_{\delta}} \right\rceil \cdot \theta_{\delta} \]
Rotate the average fork direction back into its original direction and project the second child stem direction onto the plane $ \vec{c_1} \times \vec{f} $, where $ \vec{c_1} $ is the modified direction of the first child stem and $ \vec{f} $ is the average fork direction.

\begin{figure}[H]
 \centering
 \includesvg{resources/diagrams/fork_section.svg}
 \caption{Rotating the cross section into the average direction of the two forks helps determine where the cross section needs to be divided in half.} \label{fig:forkdiv}
\end{figure}
\begin{figure}[H]
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/fork1_topdown.svg}
  \caption{Points are connected without distortion.} \label{fig:fork1}
 \end{minipage}
 \hfill
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/fork2_topdown.svg}
  \caption{Points cannot be connected without distortion.}
 \end{minipage}
\end{figure}
\begin{figure}[H]
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/fork3_topdown.svg}
  \caption{Points are connected without distortion but two extra triangles are needed.}
 \end{minipage}
 \hfill
 \begin{minipage}[b]{0.46\textwidth}
  \centering
  \includesvg{resources/diagrams/fork_topdown_angle.svg}
  \caption{A vector (a) along the cross section is rotated into the nearest vector (b) so that the cross section orientation resembles Figure \ref{fig:fork1}. The angle of the vector being rotated into is $ \vec{b}_{\theta} $.} \label{fig:forktopangle}
 \end{minipage}
\end{figure}

\item The last stage is to connect all three stems. Cross sections are projected onto three planes using the unaltered stem directions. Cross sections can also be connected with B\'{e}zier curves. Angles from the previous step are used to determine what points should be connected.
\end{enumerate}

\subsection{Leaves}

\subsubsection{Positions}

The positions of leaves are stored as distances along the parent stem. The world positions of leaves can only be determined if the parent stems are also known because leaves do not know about their parent stems.

\subsubsection{Meshes}

Each leaf is defined by a mesh which contains a set of points, indices, and texture coordinates. These meshes are stored within the plant object and are inserted into the plant geometry during mesh generation.

\subsubsection{Orientations}

The orientation of leaves is more complicated than that of stems. This is because stems are represented as two dimensional lines, whereas leaves are represented as three dimensional objects. An additional set of rotations is applied to each leaf so that all leaves by default point upward. Finally, all leaf rotations are represented using quaternions. Subsequently concatenating Euler rotations cause gimbal lock if a leaf is rotated by 90 degrees around one axis. Quaternions provide more desirable behavior.

\subsection{Materials}

The plant object stores a list of all materials that stems and leaves can have. Stems and leaves store indices of materials so that they only have to be updated in the plant object. The geometry generator needs to create vertex seams (i.e. duplicate vertices) so that textures can be wraped around the stems.

\pagebreak
\section{Shaders}

\subsection{Outlines}

Selected objects are indicated with an outline around their silhouette. The outline is achieved in two passes. The first pass draws the selected objects offscreen in solid white onto a black background. This image is stored in a texture for the second pass. During the second pass, the fragment shader refers to this texture to determine if a fragment is close to the object's silhouette edge. Even though the fragment shader needs to scan and analyze the texture, it needs to avoid branch divergence in order to keep performance acceptable.

\end{document}
